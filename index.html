<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MusicDL - Listen Together</title>
    <style>
        :root { --bg: #030303; --text: #fff; --accent: #ff0000; --dim: #aaa; }
        body { font-family: 'Roboto', sans-serif; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        .player-card { background: #111; border: 1px solid #222; border-radius: 12px; padding: 40px; width: 350px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .cover { width: 250px; height: 250px; border-radius: 8px; object-fit: cover; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
        .title { font-size: 20px; font-weight: bold; margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .artist { color: var(--dim); margin-bottom: 25px; }
        .status { font-size: 12px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; }
        .controls { display: flex; align-items: center; justify-content: center; gap: 20px; }
        .btn { background: transparent; border: none; color: white; font-size: 40px; cursor: pointer; transition: 0.2s; }
        .btn:hover { transform: scale(1.1); }
        .sync-msg { margin-top: 20px; font-size: 13px; color: #555; }
        #overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 100; display: flex; align-items: center; justify-content: center; cursor: pointer; }
    </style>
</head>
<body>

<div id="overlay" onclick="startSync()">
    <h1>Click to Start Listening</h1>
</div>

    <div class="player-card">
    <div id="status" class="status">Connecting to Host...</div>
    <img id="p-art" class="cover" src="https://via.placeholder.com/250x250?text=No+Music">
    <div id="title" class="title">No Active Session</div>
    <div id="artist" class="artist">Please use the link from the host</div>
    
    <div class="controls">
        <button id="play-btn" class="btn" onclick="togglePlay()">▶️</button>
    </div>
    
    <div id="sync-indicator" class="sync-msg">Enter a valid link to begin</div>
</div>

<div id="debug-log" style="position:fixed; bottom:0; left:0; right:0; height:150px; background:rgba(0,0,0,0.9); color:#0f0; font-family:monospace; font-size:10px; overflow-y:auto; padding:10px; border-top:1px solid #333; display:none; z-index:1000">
    <div style="display:flex; justify-content:space-between">
        <b>DEBUG LOG</b>
        <div>
            <button onclick="copyLogs()" style="background:#333; border:1px solid #555; color:#fff; cursor:pointer; padding:2px 5px; margin-right:10px">COPY LOGS</button>
            <button onclick="document.getElementById('debug-log').style.display='none'" style="background:none; border:none; color:#f00; cursor:pointer">CLOSE</button>
        </div>
    </div>
    <div id="log-content"></div>
</div>

<script>
    function copyLogs() {
        const content = document.getElementById('log-content').innerText;
        navigator.clipboard.writeText(content);
        alert("Logs copied to clipboard!");
    }
</script>
<button onclick="document.getElementById('debug-log').style.display='block'" style="position:fixed; bottom:10px; right:10px; opacity:0.3">Debug</button>

    <audio id="audio" crossorigin="anonymous"></audio>

<script>
    const logContent = document.getElementById('log-content');
    function log(msg) {
        const time = new Date().toLocaleTimeString();
        const div = document.createElement('div');
        div.textContent = `[${time}] ${msg}`;
        logContent.appendChild(div);
        logContent.scrollTop = logContent.scrollHeight;
        console.log(msg);
        
        // Update user-facing status if it looks like an error
        if (msg.includes("ERROR") || msg.includes("FAIL")) {
            document.getElementById('sync-indicator').style.color = "#ff4444";
            document.getElementById('sync-indicator').innerText = msg;
        }
    }

    let config = {};
    let lastState = null;
    let audio = document.getElementById('audio');
    let isStarted = false;

    // Diagnostic info
    log("System: Browser Environment Detected");
    log("Location: " + window.location.href);

    audio.onerror = () => {
        const errors = {
            1: "MEDIA_ERR_ABORTED",
            2: "MEDIA_ERR_NETWORK",
            3: "MEDIA_ERR_DECODE",
            4: "MEDIA_ERR_SRC_NOT_SUPPORTED (Check CORS/Permissions)"
        };
        const errType = errors[audio.error.code] || "Unknown";
        log(`!!! AUDIO ERROR: ${errType}`);
        log(`Attempted Source: ${audio.src}`);
        
        if (audio.error.code === 4) {
            log("HINT: This usually means Supabase is blocking the browser (CORS) or the file isn't Public.");
            log("Check Supabase -> Storage -> Bucket Settings -> Public.");
            log("Check Supabase -> Storage -> Settings -> CORS (Allow * origins).");
        }
    };

    audio.oncanplay = () => {
        log("Audio can now play. Ready State: " + audio.readyState);
        if (lastState && lastState.is_playing && audio.paused) {
            log("Host is playing, starting local playback...");
            audio.play().catch(e => log("Auto-play failed: " + e.message));
        }
    };

    audio.onloadstart = () => log("Audio source loading started...");
    audio.onwaiting = () => log("Audio waiting for data (buffering)...");
    audio.onplaying = () => log("Audio is now playing.");
    audio.onpause = () => log("Audio paused.");

    async function checkSupabaseConnectivity() {
        if (!config.url) return;
        log("Testing connection to Supabase...");
        try {
            const testUrl = `${config.url}/storage/v1/object/public/${config.bucket}/current_song.m4a`;
            const response = await fetch(testUrl, { method: 'HEAD', mode: 'cors' });
            log(`Connectivity Test: ${response.ok ? "PASS" : "FAIL"} (${response.status})`);
            if (!response.ok) {
                log("WARNING: Browser cannot reach the song file. Check Supabase 'music-sync' bucket is PUBLIC.");
            }
        } catch (e) {
            log("!!! CONNECTIVITY ERROR: " + e.message);
            log("This is almost certainly a CORS block in Supabase Storage.");
        }
    }

    // Parse config from URL hash
    try {
        const hash = window.location.hash.substring(1);
        if (!hash) {
            log("ERROR: No configuration found in the URL. Did you copy the full link?");
            document.getElementById('title').innerText = "Link Error";
            document.getElementById('artist').innerText = "No config found in URL";
        } else {
            config = JSON.parse(atob(hash));
            log("Config parsed from URL.");
            log(`Supabase URL: ${config.url}`);
            log(`Bucket: ${config.bucket}`);
            checkSupabaseConnectivity();
        }
    } catch (e) {        log("ERROR parsing config: " + e.message);
        alert("Invalid listener link! Please get a new link from the host.");
    }

    function startSync() {
        log("Starting sync...");
        document.getElementById('overlay').style.display = 'none';
        isStarted = true;
        audio.play().then(() => {
            log("Audio context unlocked.");
        }).catch((e) => {
            log("Audio unlock failed: " + e.message);
        });
        pollState();
        setInterval(pollState, 3000); // Poll every 3 seconds
    }

    async function pollState() {
        if (!isStarted || !config.url) return;

        try {
            log("Polling Supabase for state...");
            const res = await fetch(`${config.url}/rest/v1/playback_sync?id=eq.default`, {
                headers: {
                    "apikey": config.key,
                    "Authorization": `Bearer ${config.key}`
                }
            });
            if (!res.ok) {
                log(`Poll ERROR: ${res.status} ${res.statusText}`);
                const text = await res.text();
                log(`Response body: ${text}`);
                return;
            }
            const data = await res.json();
            if (data && data.length > 0) {
                log(`State received: Playing=${data[0].is_playing}, Time=${data[0].playback_time}, Index=${data[0].current_idx}`);
                handleStateUpdate(data[0]);
            } else {
                log("No sync data found in table 'playback_sync' for id='default'.");
            }
        } catch (e) { 
            log("Poll failed: " + e.message);
        }
    }

    async function handleStateUpdate(state) {
        // Use current_idx as a cache buster only when the song actually changes
        const songUrl = `${config.url}/storage/v1/object/public/${config.bucket}/current_song.m4a?idx=${state.current_idx}`;
        
        const isNewSong = !lastState || lastState.current_idx !== state.current_idx;
        const isFirstLoad = !lastState;

        if (isNewSong) {
            log(`New song detected (Index: ${state.current_idx}). Updating source...`);
            log(`Source URL: ${songUrl}`);
            audio.src = songUrl;
            
            // For iOS/Mobile: attempt to load and play immediately
            audio.load();
            log("Audio load() called.");
            
            // Reset lastState to ensure we sync time after load
            lastState = state; 
            return; 
        }

        // Sync playback state (Play/Pause)
        if (state.is_playing) {
            if (audio.paused) {
                log("Host is playing. Starting playback...");
                audio.play().then(() => {
                    log("Playback started successfully.");
                }).catch(e => {
                    log("Play failed: " + e.message);
                    if (e.name === "NotAllowedError") {
                        log("HINT: Browser blocked autoplay. User MUST click the screen first.");
                    }
                });
            }
            
            // Sync time if offset is > 3 seconds and audio is ready
            if (audio.readyState >= 1) { // HAVE_METADATA
                const diff = Math.abs(audio.currentTime - state.playback_time);
                if (diff > 3) { 
                    log(`Time drift detected (${diff.toFixed(2)}s). Adjusting to ${state.playback_time.toFixed(2)}s`);
                    audio.currentTime = state.playback_time;
                }
            } else {
                log(`Audio not ready for seek (readyState: ${audio.readyState})`);
            }
        } else {
            if (!audio.paused) {
                log("Host paused. Pausing playback...");
                audio.pause();
            }
        }

        // Sync volume
        if (Math.abs(audio.volume - state.volume) > 0.01) {
            audio.volume = state.volume;
        }

        document.getElementById('status').innerText = state.is_playing ? "Live Now" : "Host Paused";
        document.getElementById('play-btn').innerText = audio.paused ? '▶️' : '⏸️';
        
        document.getElementById('title').innerText = state.title || "Unknown Title";
        document.getElementById('artist').innerText = state.artist || "Unknown Artist";
        document.getElementById('sync-indicator').innerText = "Syncing with Host in Real-time";
        document.getElementById('sync-indicator').style.color = "#555";

        // Update cover if title changed (simplistic check)
        if (isNewSong) {
            document.getElementById('p-art').src = `https://via.placeholder.com/250x250?text=${encodeURIComponent(state.title || 'Music')}`;
        }
        
        lastState = state;
    }

    function togglePlay() {
        if (audio.paused) {
            // When user clicks play, force sync back to host time
            if (lastState) {
                audio.currentTime = lastState.playback_time;
                audio.play();
            }
        } else {
            audio.pause();
        }
        document.getElementById('play-btn').innerText = audio.paused ? '▶️' : '⏸️';
    }

    // Prevent seeking
    audio.onseeking = () => {
        if (lastState && Math.abs(audio.currentTime - lastState.playback_time) > 2) {
            audio.currentTime = lastState.playback_time;
        }
    };
</script>
</body>
</html>
