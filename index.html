<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MusicDL - Listen Together</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <style>
        :root { --bg: #030303; --text: #fff; --accent: #ff0000; --dim: #aaa; }
        body { font-family: 'Roboto', sans-serif; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        .player-card { background: #111; border: 1px solid #222; border-radius: 12px; padding: 30px; width: 350px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .cover { width: 250px; height: 250px; border-radius: 8px; object-fit: cover; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.4); background: #222 url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM0NDQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNOSAxOGwtNS01IDUtNSIvPjxwYXRoIGQ9Ik0yMCAxM0g0Ii8+PC9zdmc+') center/40% no-repeat; transition: opacity 0.3s; }
        .title { font-size: 18px; font-weight: bold; margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; height: 22px; }
        .artist { color: var(--dim); margin-bottom: 20px; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; height: 18px; }
        .status { font-size: 11px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; font-weight: bold; }
        
        .progress-area { margin-bottom: 20px; }
        .progress-bar-container { background: #333; height: 4px; border-radius: 2px; width: 100%; position: relative; margin-bottom: 8px; cursor: pointer; }
        .progress-fill { background: var(--accent); height: 100%; width: 0%; border-radius: 2px; transition: width 0.1s linear; }
        .time-info { display: flex; justify-content: space-between; font-size: 12px; color: var(--dim); }

        .controls { display: flex; align-items: center; justify-content: center; gap: 20px; }
        .btn { background: transparent; border: none; color: white; font-size: 40px; cursor: pointer; transition: 0.2s; padding: 0; line-height: 1; }
        .btn:hover { transform: scale(1.1); }
        .sync-msg { margin-top: 20px; font-size: 12px; color: #555; height: 15px; }
        #debug-log { position:fixed; bottom:0; left:0; right:0; height:150px; background:rgba(0,0,0,0.9); color:#0f0; font-family:monospace; font-size:10px; overflow-y:auto; padding:10px; border-top:1px solid #333; display:none; z-index:1000 }
    </style>
</head>
<body>

<div class="player-card">
    <div id="status" class="status">Offline</div>
    <img id="p-art" class="cover" style="opacity: 1">
    <div id="title" class="title">Welcome</div>
    <div id="artist" class="artist">Ready to Sync</div>
    
    <div class="progress-area">
        <div class="progress-bar-container" onclick="seek(event)">
            <div id="progress-fill" class="progress-fill"></div>
        </div>
        <div class="time-info">
            <span id="curr-time">0:00</span>
            <span id="total-time">0:00</span>
        </div>
    </div>

    <div class="controls">
        <button id="play-btn" class="btn" onclick="togglePlay()">▶️</button>
    </div>
    
    <div id="sync-indicator" class="sync-msg">Click Connect to start listening</div>
    <button onclick="startSync()" id="connect-btn" style="margin-top:20px; background:var(--accent); border:none; color:white; padding:10px 25px; border-radius:20px; font-weight:bold; cursor:pointer;">Connect to Session</button>
</div>

<div id="debug-log">
    <div style="display:flex; justify-content:space-between">
        <b>DEBUG LOG</b>
        <div>
            <button onclick="copyLogs()" style="background:#333; border:1px solid #555; color:#fff; cursor:pointer; padding:2px 5px; margin-right:10px">COPY LOGS</button>
            <button onclick="document.getElementById('debug-log').style.display='none'" style="background:none; border:none; color:#f00; cursor:pointer">CLOSE</button>
        </div>
    </div>
    <div id="log-content"></div>
</div>

<button onclick="document.getElementById('debug-log').style.display='block'" style="position:fixed; bottom:10px; right:10px; opacity:0.3; background:none; border:none; color:white; cursor:pointer">Debug</button>

<audio id="audio" crossorigin="anonymous"></audio>

<script>
    const logContent = document.getElementById('log-content');
    function log(msg) {
        const time = new Date().toLocaleTimeString();
        const div = document.createElement('div');
        div.textContent = `[${time}] ${msg}`;
        if (logContent) {
            logContent.appendChild(div);
            logContent.scrollTop = logContent.scrollHeight;
        }
        console.log(msg);
        
        const indicator = document.getElementById('sync-indicator');
        if (indicator && (msg.includes("ERROR") || msg.includes("FAIL"))) {
            indicator.style.color = "#ff4444";
            indicator.innerText = msg;
        }
    }

    function formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return "0:00";
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    function copyLogs() {
        const content = document.getElementById('log-content').innerText;
        navigator.clipboard.writeText(content);
        alert("Logs copied to clipboard!");
    }

    const defaultConfig = {
        url: "https://tlxkevdgvwiomkokwjme.supabase.co",
        key: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRseGtldmRndndpb21rb2t3am1lIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc3MDQwNDE1OSwiZXhwIjoyMDg1OTgwMTU5fQ.UXMUEzYKBCYzPRw8CymCGvFumIFQRAhDI5OD86yAFZM",
        bucket: "music-sync"
    };

    let config = { ...defaultConfig };

    try {
        if (window.location.hash) {
            const hash = window.location.hash.substring(1);
            const decoded = JSON.parse(atob(hash));
            if (decoded.url && decoded.key) {
                config = { ...config, ...decoded };
                console.log("Config loaded from hash:", config.url);
            }
        }
    } catch (e) {
        console.error("Failed to parse hash config:", e);
    }

    let lastState = null;
    let audio = document.getElementById('audio');
    let isStarted = false;
    let isManualPaused = false;
    let syncInterval = null;
    let currentLoadTimeout = null;
    let loadingSongIdx = -1;
    let retryCount = 0;

    audio.onerror = () => {
        if (!audio.error) return;
        if (!audio.src || audio.src === window.location.href || audio.src.startsWith('data:')) return;

        const errors = { 1: "ABORTED", 2: "NETWORK", 3: "DECODE", 4: "SRC_NOT_SUPPORTED" };
        if (audio.error.code === 4) {
            log(`Track not ready (Waiting for host to upload...)`);
        } else {
            log(`!!! AUDIO ERROR: ${errors[audio.error.code] || "Unknown"}`);
        }
        
        if (audio.error.code === 4 || audio.error.code === 2) {
            retryCount++;
            const delay = Math.min(2000 * retryCount, 15000);
            log(`Retrying in ${delay/1000}s... (Attempt ${retryCount})`);
            document.getElementById('status').innerText = `Syncing... (${retryCount})`;
            
            if (currentLoadTimeout) clearTimeout(currentLoadTimeout);
            currentLoadTimeout = setTimeout(() => { 
                if (lastState) {
                    loadingSongIdx = -1; 
                    handleStateUpdate(lastState, true); 
                }
            }, delay);
        }
    };

    audio.ontimeupdate = () => {
        const fill = document.getElementById('progress-fill');
        const curr = document.getElementById('curr-time');
        const total = document.getElementById('total-time');
        if (audio.duration) {
            fill.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
            total.innerText = formatTime(audio.duration);
        }
        curr.innerText = formatTime(audio.currentTime);
    };

    function startSync() {
        log("Connecting to Supabase...");
        document.getElementById('connect-btn').style.display = 'none';
        document.getElementById('status').innerText = "Connecting...";
        isStarted = true;
        
        audio.play().then(() => {
            log("Audio context unlocked.");
            audio.pause();
        }).catch(e => log("Initial unlock error: " + e.message));

        pollState();
        if (syncInterval) clearInterval(syncInterval);
        syncInterval = setInterval(pollState, 2500);
    }

    async function pollState() {
        if (!isStarted) return;
        try {
            const res = await fetch(`${config.url}/rest/v1/playback_sync?id=eq.default`, {
                headers: { 
                    "apikey": config.key, 
                    "Authorization": `Bearer ${config.key}`,
                    "Cache-Control": "no-cache"
                }
            });
            const data = await res.json();
            if (data && data.length > 0) handleStateUpdate(data[0]);
        } catch (e) { log("Poll failed: " + e.message); }
    }

    async function handleStateUpdate(state, forceReload = false) {
        if (!state) return;
        
        const hostIdx = (state.current_idx !== undefined && state.current_idx !== null) ? state.current_idx : -1;
        const hostSongId = state.song_id || "";
        const hostPlaying = !!state.is_playing;
        const hostTitle = state.title || "Unknown Title";
        const hostArtist = state.artist || "Unknown Artist";
        const isUploading = state.playback_time === -1;
        let hostTime = isUploading ? 0 : (state.playback_time || 0);

        if (state.updated_at && hostPlaying && !isUploading) {
            const updatedAt = new Date(state.updated_at).getTime();
            const now = Date.now();
            const latency = (now - updatedAt) / 1000;
            if (latency > 0 && latency < 30) hostTime += latency;
        }

        // Track change detection using Song ID
        const isNewSong = (!lastState || hostSongId !== lastState.song_id) && hostSongId !== "";

        if (isNewSong && !forceReload) {
            log(`Track change detected: ${hostTitle} (ID: ${hostSongId}). Host ${isUploading ? "is uploading..." : "is ready"}`);
            
            // 1. COMPLETELY PURGE OLD AUDIO
            audio.pause();
            audio.removeAttribute('src'); 
            audio.load();
            
            // 2. RESET UI (Prioritize Song, Icon stays blank)
            document.getElementById('p-art').style.opacity = '0';
            document.getElementById('title').innerText = hostTitle;
            document.getElementById('artist').innerText = hostArtist;
            document.getElementById('status').innerText = isUploading ? "Waiting for Host..." : "Loading...";
            document.getElementById('progress-fill').style.width = '0%';
            
            loadingSongIdx = hostIdx; // We'll keep this as a flag that we're loading
            retryCount = 0;
            if (currentLoadTimeout) clearTimeout(currentLoadTimeout);
            
            // Start loading process
            if (!isUploading) {
                currentLoadTimeout = setTimeout(() => { handleStateUpdate(state, true); }, 500);
            }
            
            lastState = state;
            return;
        }

        // Transition from Uploading -> Ready
        if (lastState && lastState.song_id === hostSongId && isUploading === false && lastState.playback_time === -1 && !forceReload) {
            log(`Host upload finished. Starting load for ${hostSongId}...`);
            handleStateUpdate(state, true);
            return;
        }

        if (forceReload && hostSongId !== "") {
            log(`Loading track: ${hostTitle} (ID: ${hostSongId})`);
            document.getElementById('status').innerText = "Fetching Audio...";
            
            const cacheBust = `v=${Date.now()}`;
            const songUrl = `${config.url}/storage/v1/object/public/${config.bucket}/${hostSongId}.m4a?${cacheBust}`;
            
            // Force reset
            audio.pause();
            audio.src = "";
            audio.load();
            
            // Attempt to load song
            setTimeout(() => {
                log(`Source set to: ${hostSongId}.m4a`);
                audio.src = songUrl;
                audio.load();
                
                isManualPaused = false; 
                
                const onCanPlay = () => {
                    log("Audio ready. Syncing position...");
                    syncPosition(hostTime, "InitialSync");
                    if (hostPlaying) {
                        audio.play().then(() => {
                            document.getElementById('status').innerText = "Live";
                        }).catch(e => {
                            log("Play blocked: Click Play to join.");
                            document.getElementById('status').innerText = "Click Play";
                        });
                    }
                    loadingSongIdx = -1;
                    currentLoadTimeout = null;
                    audio.removeEventListener('canplay', onCanPlay);
                    
                    // AFTER song is ready, load cover
                    const coverUrl = `${config.url}/storage/v1/object/public/${config.bucket}/${hostSongId}.jpg?${cacheBust}`;
                    const img = document.getElementById('p-art');
                    img.src = coverUrl;
                    img.onload = () => { img.style.opacity = '1'; };
                    img.onerror = () => { img.src = ""; img.style.opacity = '1'; };
                };
                audio.addEventListener('canplay', onCanPlay);
            }, 100);
            
            lastState = state;
            return;
        }

        // Standard Sync
        if (loadingSongIdx === -1) {
            if (isUploading) {
                document.getElementById('status').innerText = "Host is switching...";
                if (!audio.paused) audio.pause();
            } else if (hostPlaying && !isManualPaused) {
                if (audio.paused && audio.readyState >= 2) {
                    audio.play().catch(e => {});
                }
                const diff = audio.currentTime - hostTime;
                if (Math.abs(diff) > 2.5) syncPosition(hostTime, "Drift");
            } else if (!hostPlaying && !audio.paused) {
                audio.pause();
                syncPosition(hostTime, "Host Pause");
            }
            
            if (!isUploading) {
                document.getElementById('status').innerText = hostPlaying ? (isManualPaused ? "Paused by You" : "Live") : "Host Paused";
            }
        }

        document.getElementById('play-btn').innerText = audio.paused ? '▶️' : '⏸️';
        lastState = state;
    }

    function syncPosition(t, reason) {
        if (!audio.src || isNaN(t)) return;
        const apply = () => {
            // Only seek if difference is significant to avoid stutter
            if (Math.abs(audio.currentTime - t) > 0.5) {
                audio.currentTime = t;
                log(`Sync (${reason}) to ${t.toFixed(1)}s`);
            }
        };

        if (audio.readyState >= 1) apply();
        else {
            const onReady = () => { apply(); audio.removeEventListener('loadedmetadata', onReady); };
            audio.addEventListener('loadedmetadata', onReady);
        }
    }

    function togglePlay() {
        if (audio.paused) {
            isManualPaused = false;
            if (lastState) syncPosition(lastState.playback_time, "Manual Resume");
            audio.play().catch(e => log("Playback failed: " + e.message));
        } else {
            isManualPaused = true;
            audio.pause();
        }
        document.getElementById('play-btn').innerText = audio.paused ? '▶️' : '⏸️';
    }

    function seek(e) {
        if (!audio.duration) return;
        const bar = e.currentTarget;
        const rect = bar.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const pct = x / rect.width;
        audio.currentTime = pct * audio.duration;
        log(`Manual seek to ${formatTime(audio.currentTime)}`);
    }
</script>
</body>
</html>
